program Heap;
   uses (* HeapTrc {Контроль кучи, всегда первая !} ,*)
        Crt,Windows;

   {$Calling stdcall}
   {$S+}                        // Stack checking, default OFF
   {MaxStackSize 4096}          // <= $7FFFFFFFF
// {$M 4096,4996}               // StackSize,HeapSize

   Const N=10; M=4000;

   Type
     Mas=array[1..N] of Longint;
     Arr=array of Longint;  // ОТКРЫТЫЙ массив, начиная с нуля!!
     Mat=array of array of Longint;
     pMas=^Mas;

   var
     x: Longword; GetHeap: Longword; i: word;
     xMas: Mas=(1,2,3,4,5,6,7,8,9,10);
     xArr,yArr: Arr; // ДИНАМИЧЕСКИЙ открытый массив
     ptr: Pointer; LPtr:^Longint;
     Matrix: Mat;
     z: pMas; pLong: ^Longint;
     Ansi: AnsiString;

   Procedure pArr(var x:array of Longint); // параметр - абстрактный массив
      var i:Longint;
   begin
      for i:=0 to high(x) do x[i]:=-3*i;
//    WriteLn('x[5]=',x[5],' high(x)=',high(x)) // начиная с x[0] !!
   end;

   Procedure pMat(var x:Mat);
   begin
      Write('high(x)=',high(x),' high(x[1])=',high(x[1]));
      Writeln(' Length(x)=',Length(x),' Length(x[1])=',Length(x[1]))
   end;

   Procedure PrintHeap(x: String);
   begin
     Writeln(x);
     with getHeapStatus do
       WriteLn({'TotalAddrSpace=',TotalAddrSpace:6,}
               '     TotalAllocated=',TotalAllocated:6
               {,' TotalFree=',TotalFree:6})
   end;

begin {$R+}
   ClrScr; gotoXY(1,3);
   SetConsoleTitle ('Работа с кучей');
   ReturnNilIfGrowHeapFails:=true;
{  New,GetMem,ReallocMem возвращают nil при ошибке,
   иначе RunTimeError
}

// WriteLn('Начало кучи=',Heaporg,' Конец кучи=',heapend); Не работает
// Mark(ptr); Не работает
   GetHeap:=getHeapStatus.TotalAllocated;
   with getHeapStatus do
     WriteLn('TotalAddrSpace=',TotalAddrSpace:6,
             ' TotalAllocated=',TotalAllocated:6,' TotalFree=',TotalFree:6);
   WriteLn;

   PrintHeap('Начало работы с кучей');
   SetLength(xArr,M);     // Порождение xArr[0..M-1] of Longint;
   PrintHeap('Порождение xArr[0..3999] of Longint = 16000 байт');
   pArr(xArr); yArr:=xArr; xArr:=nil; // Уничтожение массива xArr
   PrintHeap('Уничтожение xArr[0..3999] of Longint, память НЕ освобождается!');
// pArr(yArr);  // ОШИБКА, yArr=xArr УНИЧТОЖЕН
   x:=Longword(yArr); yArr:=nil; // К сожалению, xArr УНИЧТОЖАЕТСЯ !
   PrintHeap('Уничтожение yArr=xArr of Longint, память освобождается!');
// xArr:=Arr(x); ОШИБКА! xArr указывает на уже НЕ СУЩЕСТВУЮЩИЙ массив 
// WriteLn('xArr[5]=',xArr[5]); Run Time Error 204, xArr уже был УНИЧТОЖЕН
// xArr:=nil; ОШИБКА! Run Time Error 204, xArr уже был УНИСТОЖЕН 
   new(LPtr); PrintHeap('Порождение Longint, 16 (миним.блок) байт !');
   dispose(LPtr); PrintHeap('Уничтожение Longint');
   SetLength(Matrix,10,20); //Matrix[0..9,0..19] of Longint;
   PrintHeap('Порождение Matrix[0..9,0..19] of Longint = 800 байт');
   pMat(Matrix); SetLength(Matrix,5,10); pMat(Matrix);
   PrintHeap('Изменение размера Matrix[0..4,0..9] of Longint = 200 байт');
   Matrix:=nil; // Уничтожение матрицы
   PrintHeap('Уничтожение Matrix[0..4,0..9] of Longint = 200 байт');
   new(z); z^:=xMas;
   PrintHeap('Порождение z^=[1..10] of Longint = 40 байт');
   Writeln(z^[1]:3,z^[2]:3,' sizeof(z^)=',sizeof(z^));
// Работа с указателями
   z:=pMas(Longword(z)+4);  // Это z:=z+1 !
   Writeln('z=@xMas[2]; z^[1]=',z^[1]:3,' z^[2]=',z^[2]:3);
   pLong:=@z^[1];           // pLong = @xMas[2]
   pLong:=pLong+1;          // pLong:=pLong+1 = @xMas[3]; можно inc(pLong);
   Writeln('pLong=@z^[2]=xMas[3]=',pLong^:3);
// dispose(z); - ошибка, z уже не указывает на начало массива !!!
   z:=pMas(Longword(z)-4);  // Это z:=z-1, снова указывает на начало массива
   dispose(z);
   PrintHeap('Уничтожение z^=[1..10] of Longint = 40 байт');

   SetLength(Ansi,20000);
   PrintHeap('Порождение строки Ansi = 20000 байт');
   Writeln('Длина строки Ansi = ',Length(Ansi));
   SetLength(Ansi,0); // Можно уничтожить и так: Ansi:='';
   PrintHeap('Уничтожение Ansi = 20000 байт');


   WriteLn;
   with getHeapStatus do
     WriteLn('TotalAddrSpace=',TotalAddrSpace:6,
             ' TotalAllocated=',TotalAllocated:6,' TotalFree=',TotalFree:6);

   GetHeap:=GetHeap-getHeapStatus.TotalAllocated;
   Writeln(#13#10,'    Утечка памяти = ',GetHeap:6);

   readln;
end.
